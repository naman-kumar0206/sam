std::string generate_html_from_dom(const json &node, int &index, int depth = 0) {
    std::ostringstream out;

    std::function<void(const json &, int)> traverse = [&](const json &node, int depth) {
        if (!node.contains("nodeName")) return;

        std::string tag = node["nodeName"];
        std::string indent(depth * 2, ' ');  // 2-space indentation

        // Open tag
        out << indent << "<" << tag;

        if (node.contains("attributes")) {
            auto attrs = node["attributes"];
            for (size_t i = 0; i + 1 < attrs.size(); i += 2) {
                std::string key = attrs[i];
                std::string val = attrs[i + 1];
                out << " " << key << "=\"" << val << "\"";
            }
        }

        out << ">";

        // Add text content if any
        if (node.contains("nodeValue") && !node["nodeValue"].is_null()) {
            out << node["nodeValue"].get<std::string>();
        }

        // If clickable
        if (tag == "A" || tag == "BUTTON" || tag == "INPUT") {
            out << "  <!-- [Clickable #" << index << "] -->";
            index++;
        }

        out << "\n";

        if (node.contains("children")) {
            for (const auto &child : node["children"]) {
                traverse(child, depth + 1);
            }
        }

        out << indent << "</" << tag << ">\n";
    };

    traverse(node, depth);
    return out.str();
}





if (j.contains("result") && j["result"].contains("root")) {
    std::cout << "ðŸ“¦ DOM received. Indexing clickable elements...\n";
    int index = 1;

    // âœ… Generate HTML
    std::string html = generate_html_from_dom(j["result"]["root"], index);
    std::cout << html << "\n";  // or write to a file

    dom_received = true;
    lws_cancel_service(context);
}

