#include <libwebsockets.h>
#include <rapidjson/document.h>
#include <rapidjson/stringbuffer.h>
#include <rapidjson/writer.h>
#include <iostream>
#include <string>
#include <vector>
#include <cstring>

using namespace rapidjson;

static int callback_cdp(struct lws *wsi, enum lws_callback_reasons reason,
                        void *user, void *in, size_t len)
{
    switch (reason)
    {
    case LWS_CALLBACK_CLIENT_ESTABLISHED:
        lwsl_user("Connected to CDP\n");
        lws_callback_on_writable(wsi);
        break;

    case LWS_CALLBACK_CLIENT_WRITEABLE:
    {
        std::string msg = R"({
            \"id\": 1,
            \"method\": \"DOM.getDocument\",
            \"params\": { \"depth\": 1, \"pierce\": true }
        })";

        std::vector<unsigned char> buf(LWS_PRE + msg.size());
        std::memcpy(buf.data() + LWS_PRE, msg.c_str(), msg.size());
        lws_write(wsi, buf.data() + LWS_PRE, msg.size(), LWS_WRITE_TEXT);
        break;
    }

    case LWS_CALLBACK_CLIENT_RECEIVE:
    {
        std::string data((const char *)in, len);
        std::cout << "Received: " << data << std::endl;

        Document response;
        response.Parse(data.c_str());

        if (response.HasMember("id") && response["id"].GetInt() == 1 && response.HasMember("result"))
        {
            const Value &root = response["result"]["root"];
            int nodeId = root["nodeId"].GetInt();

            StringBuffer sb;
            Writer<StringBuffer> writer(sb);

            writer.StartObject();
            writer.Key("id");
            writer.Int(2);
            writer.Key("method");
            writer.String("DOM.getOuterHTML");
            writer.Key("params");
            writer.StartObject();
            writer.Key("nodeId");
            writer.Int(nodeId);
            writer.EndObject();
            writer.EndObject();

            std::string msg2 = sb.GetString();
            std::vector<unsigned char> buf(LWS_PRE + msg2.size());
            std::memcpy(buf.data() + LWS_PRE, msg2.c_str(), msg2.size());
            lws_write(wsi, buf.data() + LWS_PRE, msg2.size(), LWS_WRITE_TEXT);
        }
        else if (response.HasMember("id") && response["id"].GetInt() == 2 && response.HasMember("result"))
        {
            std::string outerHTML = response["result"]["outerHTML"].GetString();
            std::cout << "DOM HTML:\n" << outerHTML << std::endl;
        }

        break;
    }

    case LWS_CALLBACK_CLOSED:
        lwsl_user("Connection closed\n");
        break;

    default:
        break;
    }

    return 0;
}

static struct lws_protocols protocols[] = {
    {"cdp-protocol", callback_cdp, 0, 4096},
    {nullptr, nullptr, 0, 0} // terminator
};

int main()
{
    struct lws_context_creation_info info;
    memset(&info, 0, sizeof(info));
    info.port = CONTEXT_PORT_NO_LISTEN;
    info.protocols = protocols;

    struct lws_context *context = lws_create_context(&info);
    if (!context)
    {
        std::cerr << "Failed to create context" << std::endl;
        return -1;
    }

    struct lws_client_connect_info ccinfo = {};
    ccinfo.context = context;
    ccinfo.address = "localhost";
    ccinfo.port = 9222;
    ccinfo.path = "/devtools/page/<your-tab-id>"; // <-- Replace with correct tab ID
    ccinfo.host = ccinfo.address;
    ccinfo.origin = ccinfo.address;
    ccinfo.protocol = protocols[0].name;

    if (!lws_client_connect_via_info(&ccinfo))
    {
        std::cerr << "Connection failed" << std::endl;
        lws_context_destroy(context);
        return -1;
    }

    while (lws_service(context, 1000) >= 0) {}

    lws_context_destroy(context);
    return 0;
}
