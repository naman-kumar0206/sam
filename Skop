#include <libwebsockets.h>
#include <nlohmann/json.hpp>
#include <iostream>
#include <map>
#include <string>
#include <sstream>
#include <vector>
#include <cstring>

extern std::string WS_URL_PATH;  // From your main file

using json = nlohmann::json;

static struct lws_context *context;
static struct lws *wsi_client = nullptr;
static std::string received_payload;
static int send_counter = 1;
static bool dom_received = false;

// Utility: Build JSON message
std::string build_command(int id, const std::string &method, const json &params = {}) {
    json j;
    j["id"] = id;
    j["method"] = method;
    if (!params.empty()) {
        j["params"] = params;
    }
    return j.dump();
}

// Recursive DOM traversal to index clickable elements
void traverse_dom(const json &node, int &index) {
    if (!node.contains("nodeName")) return;

    std::string nodeName = node["nodeName"];
    std::string description;

    if (nodeName == "A" || nodeName == "BUTTON" || nodeName == "INPUT") {
        description = nodeName;
        if (node.contains("attributes")) {
            auto attrs = node["attributes"];
            for (size_t i = 0; i + 1 < attrs.size(); i += 2) {
                std::string key = attrs[i];
                std::string val = attrs[i + 1];
                if (key == "id" || key == "class" || key == "name") {
                    description += " [" + key + "=" + val + "]";
                }
            }
        }
        std::cout << "Clickable Element #" << index++ << ": " << description << "\n";
    }

    if (node.contains("children")) {
        for (const auto &child : node["children"]) {
            traverse_dom(child, index);
        }
    }
}

// WebSocket callback
static int callback_cdp(struct lws *wsi, enum lws_callback_reasons reason,
                        void *user, void *in, size_t len) {
    switch (reason) {
        case LWS_CALLBACK_CLIENT_ESTABLISHED:
            std::cout << "✅ WebSocket connection established.\n";

            // Send commands: DOM.enable then DOM.getDocument
            lws_callback_on_writable(wsi);
            break;

        case LWS_CALLBACK_CLIENT_WRITEABLE: {
            static int stage = 0;
            std::string msg;

            if (stage == 0) {
                msg = build_command(send_counter++, "DOM.enable");
            } else if (stage == 1) {
                msg = build_command(send_counter++, "DOM.getDocument", {{"depth", 3}, {"pierce", true}});
            } else {
                return -1;
            }

            stage++;
            std::vector<unsigned char> buf(LWS_PRE + msg.size());
            std::memcpy(buf.data() + LWS_PRE, msg.c_str(), msg.size());
            lws_write(wsi, buf.data() + LWS_PRE, msg.size(), LWS_WRITE_TEXT);
            return 0;
        }

        case LWS_CALLBACK_CLIENT_RECEIVE: {
            std::string response((const char*)in, len);
            received_payload += response;

            try {
                auto j = json::parse(received_payload);
                if (j.contains("result") && j["result"].contains("root")) {
                    std::cout << "📦 DOM received, indexing clickable elements...\n";
                    int index = 1;
                    traverse_dom(j["result"]["root"], index);
                    dom_received = true;
                    lws_cancel_service(context);  // Close connection after DOM parse
                }
                received_payload.clear();
            } catch (...) {
                // Wait for more payload if it's partial
            }
            break;
        }

        case LWS_CALLBACK_CLIENT_CONNECTION_ERROR:
            std::cerr << "❌ Connection error.\n";
            dom_received = true;
            break;

        case LWS_CALLBACK_CLOSED:
            std::cout << "🔒 Connection closed.\n";
            dom_received = true;
            break;

        default:
            break;
    }

    return 0;
}

// Protocols list
static struct lws_protocols protocols[] = {
    {
        "cdp-protocol",
        callback_cdp,
        0,
        65536,
    },
    { NULL, NULL, 0, 0 } // terminator
};

// Function to run the WebSocket client
void run_websocket() {
    struct lws_context_creation_info info = {};
    info.port = CONTEXT_PORT_NO_LISTEN;
    info.protocols = protocols;

    context = lws_create_context(&info);
    if (!context) {
        std::cerr << "❌ Failed to create lws context\n";
        return;
    }

    std::string full_url = "ws://localhost:9222" + WS_URL_PATH;
    struct lws_client_connect_info ccinfo = {};
    ccinfo.context = context;
    ccinfo.address = "localhost";
    ccinfo.port = 9222;
    ccinfo.path = WS_URL_PATH.c_str();
    ccinfo.host = lws_canonical_hostname(context);
    ccinfo.origin = "origin";
    ccinfo.protocol = protocols[0].name;
    ccinfo.ssl_connection = 0;

    wsi_client = lws_client_connect_via_info(&ccinfo);
    if (!wsi_client) {
        std::cerr << "❌ Failed to connect to WebSocket\n";
        return;
    }

    while (!dom_received) {
        lws_service(context, 100);
    }

    lws_context_destroy(context);
}
