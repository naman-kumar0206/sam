#include <iostream>
#include <map>
#include <string>
#include <sstream>
#include <rapidjson/document.h>
#include <rapidjson/stringbuffer.h>
#include <rapidjson/writer.h>
#include <libwebsockets.h>

// Element structure
struct ClickableElement {
    std::string tag;
    std::string nodeId;
    std::string outerHTML;
    int index;
};

// Placeholder: store elements indexed by ID
std::map<int, ClickableElement> clickableElements;

// === WebSocket Callbacks ===
static int callback_ws(struct lws* wsi, enum lws_callback_reasons reason,
                       void* user, void* in, size_t len) {
    switch (reason) {
        case LWS_CALLBACK_CLIENT_RECEIVE: {
            std::string json_msg((const char*)in, len);
            rapidjson::Document doc;
            doc.Parse(json_msg.c_str());

            if (doc.HasParseError()) {
                std::cerr << "JSON parse error\n";
                return -1;
            }

            // Handle result from querySelectorAll
            if (doc.HasMember("result")) {
                const auto& result = doc["result"];
                if (result.HasMember("result")) {
                    const auto& list = result["result"]["value"];
                    int idx = 0;
                    for (auto it = list.MemberBegin(); it != list.MemberEnd(); ++it) {
                        const auto& val = it->value;
                        if (val.HasMember("description")) {
                            std::string desc = val["description"].GetString();
                            if (desc.find("<button") != std::string::npos || desc.find("<a") != std::string::npos) {
                                ClickableElement elem;
                                elem.tag = (desc.find("<a") != std::string::npos) ? "A" : "BUTTON";
                                elem.index = idx++;
                                elem.outerHTML = desc;
                                clickableElements[elem.index] = elem;
                            }
                        }
                    }
                    std::cout << "âœ… Found " << clickableElements.size() << " clickable elements.\n";
                }
            }

            break;
        }

        case LWS_CALLBACK_CLIENT_ESTABLISHED: {
            std::cout << "ðŸ”— Connected to browser WebSocket\n";

            // Send Runtime.globalLexicalScopeNames just to check connection
            std::string message = R"({
                "id": 1,
                "method": "Runtime.evaluate",
                "params": {
                    "expression": "document.querySelectorAll('a,button')",
                    "returnByValue": true
                }
            })";

            lws_write(wsi, (unsigned char*)message.c_str(), message.length(), LWS_WRITE_TEXT);
            break;
        }

        default:
            break;
    }
    return 0;
}

// === Protocols ===
static struct lws_protocols protocols[] = {
    {
        "cdp-protocol",
        callback_ws,
        0,
        4096,
    },
    {NULL, NULL, 0, 0}  // terminator
};

// === Entry Point ===
int main() {
    struct lws_context_creation_info info;
    struct lws_client_connect_info conn_info;

    memset(&info, 0, sizeof(info));
    info.port = CONTEXT_PORT_NO_LISTEN;
    info.protocols = protocols;

    struct lws_context* context = lws_create_context(&info);
    if (!context) {
        std::cerr << "âŒ Failed to create lws context\n";
        return 1;
    }

    memset(&conn_info, 0, sizeof(conn_info));
    conn_info.context = context;
    conn_info.address = "127.0.0.1";
    conn_info.port = 9222;
    conn_info.path = "/devtools/page/XXXXXXXX"; // Replace with actual target
    conn_info.host = conn_info.address;
    conn_info.origin = conn_info.address;
    conn_info.protocol = protocols[0].name;
    conn_info.ssl_connection = 0;

    struct lws* wsi = lws_client_connect_via_info(&conn_info);
    if (!wsi) {
        std::cerr << "âŒ Failed to connect to WebSocket\n";
        return 1;
    }

    // Event loop
    while (true) {
        lws_service(context, 100);
    }

    lws_context_destroy(context);
    return 0;
}
